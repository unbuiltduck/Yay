<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>For You ü§ç</title>
<link href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,600;1,400&family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
<style>
  *{margin:0;padding:0;box-sizing:border-box}
  body{
    min-height:100vh;background:#080808;
    display:flex;align-items:center;justify-content:center;
    overflow:hidden;font-family:'Cormorant Garamond',serif;
  }
  body::before{
    content:'';position:fixed;inset:0;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.03'/%3E%3C/svg%3E");
    pointer-events:none;z-index:1000;
  }
  canvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1}
  .message-container{
    position:fixed;
    bottom:10%;
    left:50%;
    transform:translateX(-50%);
    text-align:center;z-index:50;
    opacity:0;pointer-events:none;
    width:90%;max-width:550px;
    transition: opacity 2.5s ease;
  }
  .message-container.visible{
    opacity:1;
  }
  .msg1{
    font-family:'Playfair Display',serif;
    font-size:clamp(1.5rem,4vw,2.6rem);
    color:#f5f0ea;font-weight:400;
    letter-spacing:0.02em;line-height:1.4;margin-bottom:16px;
  }
  .msg2{
    font-family:'Cormorant Garamond',serif;
    font-size:clamp(1rem,2.5vw,1.25rem);
    color:rgba(245,240,234,0.5);font-weight:300;
    font-style:italic;letter-spacing:0.06em;line-height:1.7;
  }
  .particle{
    position:fixed;background:rgba(255,255,255,0.08);
    border-radius:50%;animation:fl linear infinite;
    pointer-events:none;z-index:2;
  }
  @keyframes fl{
    0%{transform:translateY(100vh);opacity:0}
    10%{opacity:.7}90%{opacity:.7}
    100%{transform:translateY(-10vh);opacity:0}
  }
</style>
</head>
<body>
<div class="message-container" id="msg">
  <div class="msg1">These are for you</div>
  <div class="msg2">You're doing amazing and I'm so proud of you.<br>Keep going ü§ç</div>
</div>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const msgEl = document.getElementById('msg');
let W, H, dpr;

function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const isMobile = W <= 600;

function easeOut(t) { return 1 - Math.pow(1 - t, 3); }
function easeInOut(t) { return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
function easeIn(t) { return t * t * t; }
function lerp(a, b, t) { return a + (b - a) * t; }

// ‚îÄ‚îÄ‚îÄ PHASES ‚îÄ‚îÄ‚îÄ
const PHASE_GROW_END = 4.0;
const PHASE_SNIP_START = 4.0;
const PHASE_SNIP_END = 5.5;
const PHASE_GATHER_START = 5.5;
const PHASE_GATHER_END = 8.5;
const PHASE_WRAP_START = 8.5;
const PHASE_WRAP_END = 11.0;
const PHASE_MSG_START = 11.8;

// Bouquet lands in the upper portion of the screen
const bouquetCenterX = W / 2;
const bouquetCenterY = H * 0.32;

// ‚îÄ‚îÄ‚îÄ ROSE DATA ‚îÄ‚îÄ‚îÄ
const COUNT = 7;
const groundY = H * 0.92;
const spread = isMobile ? W * 0.78 : W * 0.52;
const startXBase = (W - spread) / 2;

const roses = [];
const heightMults = [0.82, 1.0, 0.72, 1.08, 0.88, 0.68, 0.95];
const delays = [0.1, 0.5, 0.0, 0.8, 0.3, 1.0, 0.6];

for (let i = 0; i < COUNT; i++) {
  const baseH = isMobile ? 160 : 250;
  const stemH = baseH * heightMults[i];
  const x = startXBase + (spread / (COUNT - 1)) * i + (Math.random() - 0.5) * 15;

  roses.push({
    origX: x,
    origBaseY: groundY,
    stemHeight: stemH,
    growDelay: delays[i],
    bloomSize: isMobile ? 16 + Math.random() * 5 : 26 + Math.random() * 9,
    swayOff: Math.random() * Math.PI * 2,
    swayAmt: 8 + Math.random() * 6,
    swaySpd: 0.5 + Math.random() * 0.3,
    snipT: 0.2 + Math.random() * 0.1,
    bouquetAngle: 0,
    bouquetX: 0,
    bouquetY: 0,
    leaves: [],
  });

  const r = roses[roses.length - 1];
  const lc = Math.floor(stemH / 90) + 1;
  for (let l = 0; l < lc; l++) {
    r.leaves.push({
      t: 0.25 + (l / lc) * 0.45 + Math.random() * 0.04,
      side: l % 2 === 0 ? -1 : 1,
      size: isMobile ? 10 + Math.random() * 4 : 16 + Math.random() * 6,
    });
  }
}

// Bouquet arrangement - fan shape in the upper area
const fanSpread = isMobile ? 0.65 : 0.55;
roses.forEach((r, i) => {
  const t = (i / (COUNT - 1)) - 0.5;
  r.bouquetAngle = t * fanSpread;
  r.bouquetX = bouquetCenterX + Math.sin(r.bouquetAngle) * (isMobile ? 25 : 45);
  r.bouquetY = bouquetCenterY - Math.abs(t) * 15;
});

const startTime = performance.now();
let msgShown = false;

// ‚îÄ‚îÄ‚îÄ DRAWING HELPERS ‚îÄ‚îÄ‚îÄ
function getStemPt(baseX, baseY, stemH, t, sway) {
  return { x: baseX + Math.sin(t * Math.PI) * sway, y: baseY - stemH * t };
}

function drawStemSegment(points, maxTh, alpha) {
  for (let i = 0; i < points.length - 1; i++) {
    const t = i / points.length;
    const th = maxTh * (1 - t * 0.4);
    const rv = Math.floor(35 + t * 20);
    const g = Math.floor(65 + t * 30);
    const b = Math.floor(30 + t * 15);
    ctx.beginPath();
    ctx.moveTo(points[i].x, points[i].y);
    ctx.lineTo(points[i+1].x, points[i+1].y);
    ctx.strokeStyle = `rgba(${rv},${g},${b},${alpha})`;
    ctx.lineWidth = th; ctx.lineCap = 'round'; ctx.stroke();
    if (th > 1.5) {
      ctx.beginPath();
      ctx.moveTo(points[i].x - 0.4, points[i].y);
      ctx.lineTo(points[i+1].x - 0.4, points[i+1].y);
      ctx.strokeStyle = `rgba(${rv+30},${g+25},${b+20},${0.25*alpha})`;
      ctx.lineWidth = th * 0.25; ctx.stroke();
    }
  }
}

function drawLeaf(x, y, angle, side, size, alpha) {
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(angle + side * Math.PI * 0.35);
  const sz = size;
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.bezierCurveTo(sz*0.15,-sz*0.35,sz*0.6,-sz*0.35,sz,0);
  ctx.bezierCurveTo(sz*0.6,sz*0.35,sz*0.15,sz*0.35,0,0);
  const lg = ctx.createLinearGradient(0,0,sz,0);
  lg.addColorStop(0, `rgba(45,85,40,${0.9*alpha})`);
  lg.addColorStop(0.5, `rgba(60,110,52,${0.85*alpha})`);
  lg.addColorStop(1, `rgba(50,95,45,${0.75*alpha})`);
  ctx.fillStyle = lg; ctx.fill();
  ctx.beginPath(); ctx.moveTo(1,0); ctx.lineTo(sz*0.88,0);
  ctx.strokeStyle = `rgba(35,65,30,${0.45*alpha})`; ctx.lineWidth = 0.7; ctx.stroke();
  for (let v = 0.22; v < 0.82; v += 0.2) {
    ctx.beginPath();
    ctx.moveTo(sz*v,0);
    ctx.quadraticCurveTo(sz*(v+0.08),-sz*0.11,sz*(v+0.13),-sz*0.17);
    ctx.moveTo(sz*v,0);
    ctx.quadraticCurveTo(sz*(v+0.08),sz*0.11,sz*(v+0.13),sz*0.17);
    ctx.strokeStyle = `rgba(35,65,30,${0.22*alpha})`; ctx.lineWidth = 0.4; ctx.stroke();
  }
  ctx.restore();
}

function drawBloom(cx, cy, size, progress, alpha) {
  if (progress <= 0) return;
  const p = easeOut(Math.min(1, progress));
  ctx.save();
  ctx.translate(cx, cy);

  const gr = size * 1.8;
  const gg = ctx.createRadialGradient(0,0,size*0.2,0,0,gr);
  gg.addColorStop(0, `rgba(255,255,248,${0.07*p*alpha})`);
  gg.addColorStop(1, 'rgba(255,255,248,0)');
  ctx.beginPath(); ctx.arc(0,0,gr,0,Math.PI*2); ctx.fillStyle = gg; ctx.fill();

  for (let i = 0; i < 5; i++) {
    const a = (i/5)*Math.PI*2 - Math.PI*0.5;
    ctx.save(); ctx.rotate(a);
    const sL = size * 0.5 * p;
    ctx.beginPath();
    ctx.moveTo(0,2);
    ctx.bezierCurveTo(-sL*0.11,-sL*0.3,-sL*0.07,-sL*0.8,0,-sL);
    ctx.bezierCurveTo(sL*0.07,-sL*0.8,sL*0.11,-sL*0.3,0,2);
    ctx.fillStyle = `rgba(50,85,42,${0.85*p*alpha})`; ctx.fill(); ctx.restore();
  }

  const layers = [
    { n:8, sz:1.05, off:0.15, op:0.9, c:['240,236,228','228,222,212','218,212,200'] },
    { n:7, sz:0.82, off:0.65, op:0.7, c:['248,244,238','238,233,224','230,225,216'] },
    { n:6, sz:0.6, off:1.3, op:0.5, c:['252,249,244','245,241,234','240,236,228'] },
    { n:5, sz:0.4, off:1.9, op:0.3, c:['255,253,250','250,247,242','248,245,240'] },
    { n:4, sz:0.25, off:2.5, op:0.18, c:['255,254,252','252,250,247','255,254,252'] },
  ];
  layers.forEach(layer => {
    for (let i = 0; i < layer.n; i++) {
      const a = (i/layer.n)*Math.PI*2 + layer.off;
      const pS = size * layer.sz * p;
      const open = layer.op * p;
      ctx.save(); ctx.rotate(a);
      ctx.beginPath(); ctx.moveTo(0,0);
      ctx.bezierCurveTo(-pS*0.45*open,-pS*0.25,-pS*0.48*open,-pS*0.75,-pS*0.05,-pS*0.95);
      ctx.bezierCurveTo(pS*0.02,-pS*1.02,pS*0.08,-pS*1.02,pS*0.12,-pS*0.95);
      ctx.bezierCurveTo(pS*0.5*open,-pS*0.72,pS*0.47*open,-pS*0.22,0,0);
      const gd = ctx.createRadialGradient(0,-pS*0.4,0,0,-pS*0.4,pS*0.95);
      gd.addColorStop(0, `rgba(${layer.c[0]},${0.97*p*alpha})`);
      gd.addColorStop(0.5, `rgba(${layer.c[1]},${0.92*p*alpha})`);
      gd.addColorStop(1, `rgba(${layer.c[2]},${0.82*p*alpha})`);
      ctx.fillStyle = gd; ctx.fill();
      ctx.strokeStyle = `rgba(205,198,186,${0.16*p*alpha})`; ctx.lineWidth = 0.4; ctx.stroke();
      ctx.restore();
    }
  });

  ctx.beginPath(); ctx.arc(0,0,size*0.11*p,0,Math.PI*2);
  const cg = ctx.createRadialGradient(0,0,0,0,0,size*0.11*p);
  cg.addColorStop(0, `rgba(255,255,252,${0.95*p*alpha})`);
  cg.addColorStop(1, `rgba(248,245,238,${0.7*p*alpha})`);
  ctx.fillStyle = cg; ctx.fill();
  ctx.restore();
}

function drawSnipEffect(x, y, progress) {
  if (progress <= 0 || progress > 1) return;
  const r = 12 * (1 - progress);
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
  ctx.fillStyle = `rgba(255,255,230,${0.8*(1-progress)})`; ctx.fill();
  for (let i = 0; i < 5; i++) {
    const a = (i/5)*Math.PI*2 + progress*3;
    const d = 6 + progress * 20;
    ctx.beginPath(); ctx.arc(x+Math.cos(a)*d, y+Math.sin(a)*d, 1.5*(1-progress), 0, Math.PI*2);
    ctx.fillStyle = `rgba(200,230,180,${0.5*(1-progress)})`; ctx.fill();
  }
}

function drawWrap(cx, cy, width, height, progress, time) {
  if (progress <= 0) return;
  const p = easeOut(Math.min(1, progress));
  ctx.save(); ctx.translate(cx, cy);

  const paperW = width * 1.1 * p;
  const paperH = height * 1.2 * p;
  const topW = paperW * 0.9;
  const botW = paperW * 0.15;

  // Shadow
  ctx.beginPath();
  ctx.moveTo(-topW/2+3, -paperH*0.25+3);
  ctx.lineTo(topW/2+3, -paperH*0.25+3);
  ctx.lineTo(botW/2+3, paperH*0.65+3);
  ctx.lineTo(-botW/2+3, paperH*0.65+3);
  ctx.closePath();
  ctx.fillStyle = `rgba(0,0,0,${0.12*p})`; ctx.fill();

  // Paper
  ctx.beginPath();
  ctx.moveTo(-topW/2, -paperH*0.25);
  ctx.lineTo(topW/2, -paperH*0.25);
  ctx.lineTo(botW/2, paperH*0.65);
  ctx.lineTo(-botW/2, paperH*0.65);
  ctx.closePath();
  const pg = ctx.createLinearGradient(-topW/2,0,topW/2,0);
  pg.addColorStop(0, `rgba(215,200,180,${0.92*p})`);
  pg.addColorStop(0.3, `rgba(228,218,200,${0.95*p})`);
  pg.addColorStop(0.5, `rgba(235,225,210,${0.97*p})`);
  pg.addColorStop(0.7, `rgba(225,215,198,${0.95*p})`);
  pg.addColorStop(1, `rgba(210,196,175,${0.9*p})`);
  ctx.fillStyle = pg; ctx.fill();
  ctx.strokeStyle = `rgba(180,165,145,${0.4*p})`; ctx.lineWidth = 0.8; ctx.stroke();

  // Texture lines
  for (let i = 0; i < 6; i++) {
    const t = 0.15 + (i/6)*0.7;
    const lx1 = lerp(-topW/2,-botW/2,t)*0.95;
    const lx2 = lerp(topW/2,botW/2,t)*0.95;
    const ly = lerp(-paperH*0.25,paperH*0.65,t);
    ctx.beginPath(); ctx.moveTo(lx1+5,ly); ctx.lineTo(lx2-5,ly);
    ctx.strokeStyle = `rgba(190,175,155,${0.1*p})`; ctx.lineWidth = 0.3; ctx.stroke();
  }

  // Tissue paper
  if (p > 0.3) {
    const tp = Math.min(1,(p-0.3)/0.7);
    const tH = paperH * 0.18 * tp;
    for (let i = 0; i < 5; i++) {
      const tx = lerp(-topW/2*0.7,topW/2*0.7,i/4);
      const wave = Math.sin(time*1.5+i*1.2)*4*tp;
      ctx.beginPath();
      ctx.moveTo(tx-12,-paperH*0.25);
      ctx.quadraticCurveTo(tx+wave,-paperH*0.25-tH-wave*0.5,tx+12,-paperH*0.25);
      ctx.strokeStyle = `rgba(245,242,238,${0.45*tp*p})`; ctx.lineWidth = 6; ctx.lineCap='round'; ctx.stroke();
    }
  }

  // Ribbon + bow
  if (p > 0.5) {
    const rp = Math.min(1,(p-0.5)/0.5);
    const ry = -paperH*0.02;
    const rl = lerp(-topW/2,-botW/2,0.38)*0.9;
    const rr = lerp(topW/2,botW/2,0.38)*0.9;
    ctx.beginPath();
    ctx.moveTo(rl,ry-2); ctx.lineTo(rr,ry-2); ctx.lineTo(rr,ry+2); ctx.lineTo(rl,ry+2);
    ctx.closePath(); ctx.fillStyle = `rgba(180,160,140,${0.7*rp})`; ctx.fill();

    if (rp > 0.3) {
      const bp = Math.min(1,(rp-0.3)/0.7);
      const bs = 16*bp;
      ctx.beginPath(); ctx.ellipse(-bs*0.6,ry,bs,bs*0.5,-0.3,0,Math.PI*2);
      ctx.fillStyle = `rgba(190,170,150,${0.65*bp})`; ctx.fill();
      ctx.strokeStyle = `rgba(160,140,120,${0.3*bp})`; ctx.lineWidth = 0.5; ctx.stroke();
      ctx.beginPath(); ctx.ellipse(bs*0.6,ry,bs,bs*0.5,0.3,0,Math.PI*2);
      ctx.fillStyle = `rgba(195,175,155,${0.65*bp})`; ctx.fill();
      ctx.strokeStyle = `rgba(160,140,120,${0.3*bp})`; ctx.lineWidth = 0.5; ctx.stroke();
      ctx.beginPath(); ctx.ellipse(0,ry,bs*0.25,bs*0.3,0,0,Math.PI*2);
      ctx.fillStyle = `rgba(175,155,135,${0.8*bp})`; ctx.fill();
      ctx.beginPath();
      ctx.moveTo(-3,ry+bs*0.3); ctx.quadraticCurveTo(-8,ry+bs*1.2,-14,ry+bs*1.5);
      ctx.moveTo(3,ry+bs*0.3); ctx.quadraticCurveTo(8,ry+bs*1.2,14,ry+bs*1.5);
      ctx.strokeStyle = `rgba(180,160,140,${0.6*bp})`; ctx.lineWidth = 2.5; ctx.lineCap='round'; ctx.stroke();
    }
  }
  ctx.restore();
}

// ‚îÄ‚îÄ‚îÄ MAIN LOOP ‚îÄ‚îÄ‚îÄ
function animate(now) {
  const elapsed = (now - startTime) / 1000;
  ctx.clearRect(0, 0, W, H);

  // Ground line fades
  const groundAlpha = elapsed < PHASE_GATHER_START ? 1 : Math.max(0, 1 - (elapsed - PHASE_GATHER_START)/1.5);
  if (groundAlpha > 0) {
    const gg = ctx.createLinearGradient(W*0.12,0,W*0.88,0);
    gg.addColorStop(0,'transparent');
    gg.addColorStop(0.5,`rgba(255,255,255,${0.07*groundAlpha})`);
    gg.addColorStop(1,'transparent');
    ctx.beginPath(); ctx.moveTo(W*0.08,groundY); ctx.lineTo(W*0.92,groundY);
    ctx.strokeStyle = gg; ctx.lineWidth = 1; ctx.stroke();
  }

  roses.forEach((rose) => {
    const growElapsed = Math.max(0, elapsed - rose.growDelay);
    const stemGrow = easeOut(Math.min(1, growElapsed / 2.4));
    const bloomStart = rose.growDelay + 1.8;
    const bloomElapsed = Math.max(0, elapsed - bloomStart);
    const bloomProg = Math.min(1, bloomElapsed / 2.0);
    const sway = Math.sin(elapsed * rose.swaySpd + rose.swayOff) * rose.swayAmt * stemGrow;

    const snipProgress = Math.max(0, Math.min(1, (elapsed - PHASE_SNIP_START)/(PHASE_SNIP_END - PHASE_SNIP_START)));
    const snipPt = rose.snipT;
    const snipY = rose.origBaseY - rose.stemHeight * snipPt;
    const snipX = rose.origX + Math.sin(snipPt * Math.PI) * sway;

    const gatherT = Math.max(0, Math.min(1, (elapsed - PHASE_GATHER_START)/(PHASE_GATHER_END - PHASE_GATHER_START)));
    const gatherP = easeInOut(gatherT);

    if (elapsed >= PHASE_SNIP_START) {
      // Bottom stem falls
      if (snipProgress < 1) {
        const fallP = easeIn(snipProgress);
        const bottomAlpha = 1 - snipProgress;
        const segs = 8; const pts = [];
        for (let s = 0; s <= segs; s++) {
          const t = (s/segs) * snipPt;
          pts.push(getStemPt(rose.origX, rose.origBaseY + fallP*30, rose.stemHeight, t, sway*(1-fallP)));
        }
        drawStemSegment(pts, isMobile?2.2:3.0, bottomAlpha);
      }

      // Snip sparkle
      if (snipProgress > 0 && snipProgress < 0.6) {
        drawSnipEffect(snipX, snipY, snipProgress/0.6);
      }

      // Upper stem gathers into bouquet position
      const upperStemH = rose.stemHeight * (1 - snipPt);
      const targetBaseY = rose.bouquetY + upperStemH * 0.5;

      const curBaseX = lerp(rose.origX, rose.bouquetX, gatherP);
      const curBaseY = lerp(snipY + upperStemH * snipPt, targetBaseY, gatherP);
      const rotation = lerp(0, rose.bouquetAngle, gatherP);

      const segCount = 20; const pts = [];
      ctx.save();
      ctx.translate(curBaseX, curBaseY);
      ctx.rotate(rotation);

      for (let s = 0; s <= segCount; s++) {
        const t = s / segCount;
        const y = -upperStemH * t * stemGrow;
        const x = Math.sin(t * Math.PI) * sway * 0.3 * (1 - gatherP * 0.8);
        pts.push({ x, y });
      }

      drawStemSegment(pts, isMobile?2.2:3.0, 1);

      rose.leaves.forEach(leaf => {
        const adjT = (leaf.t - snipPt) / (1 - snipPt);
        if (adjT < 0 || adjT > stemGrow) return;
        const idx = Math.floor(adjT * segCount);
        if (idx >= pts.length) return;
        const p = pts[idx];
        const ni = Math.min(pts.length-1, idx+1);
        const sa = Math.atan2(pts[ni].y - p.y, pts[ni].x - p.x);
        drawLeaf(p.x, p.y, sa, leaf.side, leaf.size, 1);
      });

      if (bloomProg > 0 && pts.length > 0) {
        const tip = pts[pts.length-1];
        drawBloom(tip.x, tip.y, rose.bloomSize, bloomProg, 1);
      }

      ctx.restore();

    } else {
      // Normal growing
      const segCount = 30; const pts = [];
      for (let s = 0; s <= Math.floor(segCount * stemGrow); s++) {
        const t = s / segCount;
        pts.push(getStemPt(rose.origX, rose.origBaseY, rose.stemHeight, t, sway));
      }
      if (pts.length >= 2) {
        drawStemSegment(pts, isMobile?2.2:3.0, 1);
        rose.leaves.forEach(leaf => {
          if (leaf.t > stemGrow) return;
          const idx = Math.floor(leaf.t * segCount);
          if (idx >= pts.length) return;
          const p = pts[idx]; const ni = Math.min(pts.length-1, idx+1);
          const sa = Math.atan2(pts[ni].y-p.y, pts[ni].x-p.x);
          const appear = Math.min(1,(stemGrow-leaf.t)/0.1);
          drawLeaf(p.x, p.y, sa, leaf.side, leaf.size*appear, 1);
        });
        if (bloomProg > 0) {
          const tip = pts[pts.length-1];
          drawBloom(tip.x, tip.y, rose.bloomSize, bloomProg, 1);
        }
      }
    }
  });

  // Wrap
  const wrapT = Math.max(0, (elapsed - PHASE_WRAP_START)/(PHASE_WRAP_END - PHASE_WRAP_START));
  if (wrapT > 0) {
    const wrapCX = bouquetCenterX;
    const wrapCY = bouquetCenterY + (isMobile ? 50 : 70);
    drawWrap(wrapCX, wrapCY, isMobile?100:150, isMobile?140:200, wrapT, elapsed);
  }

  // Message
  if (elapsed >= PHASE_MSG_START && !msgShown) {
    msgShown = true;
    msgEl.classList.add('visible');
  }

  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);

// Particles
for (let i = 0; i < 15; i++) {
  const p = document.createElement('div');
  p.className = 'particle';
  p.style.left = Math.random()*100+'vw';
  p.style.animationDuration = (14+Math.random()*18)+'s';
  p.style.animationDelay = Math.random()*12+'s';
  const s = 1.5+Math.random()*2;
  p.style.width = s+'px'; p.style.height = s+'px';
  p.style.opacity = 0.03+Math.random()*0.05;
  document.body.appendChild(p);
}
</script>
</body>
</html>
